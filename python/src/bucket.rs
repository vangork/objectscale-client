use objectscale_client::bucket;
use pyo3::prelude::*;
use std::convert::From;

// Buckets are object containers that are used to control access to objects. ObjectScale supports bucket-to-bucket replication of the objects within a bucket.
#[derive(Clone, Debug, Default)]
#[pyclass(get_all)]
pub(crate) struct Bucket {
    // Name assigned to this resource in ECS. The resource name is set by a user and can be changed at any time. It is not a unique identifier.
    #[pyo3(set)]
    name: String,
    // Identifier that is generated by ECS when the resource is created. The resource Id is guaranteed to be unique and immutable across all virtual data centers for all time.
    id: String,
    // Hyperlink to the details for this resource
    link: Link,
    // Namespace
    #[pyo3(set)]
    namespace: String,
    //
    replication: String,
    // "Locked" status of a bucket
    locked: bool,
    // Bucket "file system access enabled" status
    fs_acess_enabled: bool,
    // Bucket soft quota
    soft_quota: String,
    // Bucket creation time
    created: String,
    // Bucket isStaleAllowed flag
    is_stale_allowed: bool,
    // If true Object Lock and ADO can be enabled together. See the Admin Guide for more information.
    object_lock_with_ado_allowed: bool,
    // Bucket isStaleAllowed flag
    is_tso_read_only: bool,
    // Default object lock retention mode
    default_object_lock_retention_mode: String,
    // Default object lock retention years
    default_object_lock_retention_years: i32,
    // Default object lock retention days
    default_object_lock_retention_days: i32,
    // Default bucket retention
    default_retention: i64,
    // Block size in GB
    block_size_in_g_b: i64,
    // auto-commit interval
    auto_commit_period: i64,
    // Notification size in GB
    notification_size_in_g_b: i64,
    //
    block_size_in_count: i64,
    //
    notification_size_in_count: i64,
    // Bucket isEncryptionEnabled flag
    #[pyo3(set)]
    is_encryption_enabled: bool,
    // Default retention value for the bucket.
    retention: i64,
    // Bucket's default group
    default_group: String,
    // Flag indicating the Read permission for default group
    default_group_file_read_permission: bool,
    // Flag indicating the file write permission for default group
    default_group_file_write_permission: bool,
    // Flag indicating the file execute permission for default group
    default_group_file_execute_permission: bool,
    // Flag indicating the directory read permission for default group. This is only applicable to folders created within the Filesystem-Enabled bucket. It is not applicable to files/objects
    default_group_dir_read_permission: bool,
    // Flag indicating the directory write permission for default group. This is only applicable to folders created within the Filesystem-Enabled bucket. It is not applicable to files/objects
    default_group_dir_write_permission: bool,
    // Flag indicating the directory execute permission for default group. This is only applicable to folders created within the Filesystem-Enabled bucket. It is not applicable to files/objects
    default_group_dir_execute_permission: bool,
    //
    min_max_governor: MinMaxGovernor,
    // Bucket audit delete expiration in seconds
    #[pyo3(set)]
    audit_delete_expiration: i64,
    //
    enable_advanced_metadata_search: bool,
    //
    advanced_metadata_search_target_name: String,
    //
    advanced_metadata_search_target_stream: String,
    // Optional. If true the bucket is in the process of being deleted. The bucket will be read only and no changes will be allowed on the bucket until the operation completes.
    is_empty_bucket_in_progress: bool,
    //
    meta_data: SearchMetaData,
    // Local object metadata reads bucket flag.
    local_object_metadata_reads: bool,
    // API type
    apitype: String,
    // Bucket owner
    bucket_owner: String,
    // Keywords and labels that can be added by a user to a resource to make it easy to find when doing a search.
    #[pyo3(set)]
    tags: Vec<BucketTag>,
}

impl From<bucket::Bucket> for Bucket {
    fn from(bucket: bucket::Bucket) -> Self {
        Self {
            name: bucket.name,
            id: bucket.id,
            link: Link::from(bucket.link),
            namespace: bucket.namespace,
            replication: bucket.replication,
            locked: bucket.locked,
            fs_acess_enabled: bucket.fs_acess_enabled,
            soft_quota: bucket.soft_quota,
            created: bucket.created,
            is_stale_allowed: bucket.is_stale_allowed,
            object_lock_with_ado_allowed: bucket.object_lock_with_ado_allowed,
            is_tso_read_only: bucket.is_tso_read_only,
            default_object_lock_retention_mode: bucket.default_object_lock_retention_mode,
            default_object_lock_retention_years: bucket.default_object_lock_retention_years,
            default_object_lock_retention_days: bucket.default_object_lock_retention_days,
            default_retention: bucket.default_retention,
            block_size_in_g_b: bucket.block_size_in_g_b,
            auto_commit_period: bucket.auto_commit_period,
            notification_size_in_g_b: bucket.notification_size_in_g_b,
            block_size_in_count: bucket.block_size_in_count,
            notification_size_in_count: bucket.notification_size_in_count,
            is_encryption_enabled: bucket.is_encryption_enabled,
            retention: bucket.retention,
            default_group: bucket.default_group,
            default_group_file_read_permission: bucket.default_group_file_read_permission,
            default_group_file_write_permission: bucket.default_group_file_write_permission,
            default_group_file_execute_permission: bucket.default_group_file_execute_permission,
            default_group_dir_read_permission: bucket.default_group_dir_read_permission,
            default_group_dir_write_permission: bucket.default_group_dir_write_permission,
            default_group_dir_execute_permission: bucket.default_group_dir_execute_permission,
            min_max_governor: MinMaxGovernor::from(bucket.min_max_governor),
            audit_delete_expiration: bucket.audit_delete_expiration,
            enable_advanced_metadata_search: bucket.enable_advanced_metadata_search,
            advanced_metadata_search_target_name: bucket.advanced_metadata_search_target_name,
            advanced_metadata_search_target_stream: bucket.advanced_metadata_search_target_stream,
            is_empty_bucket_in_progress: bucket.is_empty_bucket_in_progress,
            meta_data: SearchMetaData::from(bucket.meta_data),
            local_object_metadata_reads: bucket.local_object_metadata_reads,
            apitype: bucket.apitype,
            bucket_owner: bucket.bucket_owner,
            tags: bucket.tags.into_iter().map(BucketTag::from).collect(),
        }
    }
}

impl From<Bucket> for bucket::Bucket {
    fn from(bucket: Bucket) -> Self {
        Self {
            name: bucket.name,
            id: bucket.id,
            link: bucket::Link::from(bucket.link),
            namespace: bucket.namespace,
            replication: bucket.replication,
            locked: bucket.locked,
            fs_acess_enabled: bucket.fs_acess_enabled,
            soft_quota: bucket.soft_quota,
            created: bucket.created,
            is_stale_allowed: bucket.is_stale_allowed,
            object_lock_with_ado_allowed: bucket.object_lock_with_ado_allowed,
            is_tso_read_only: bucket.is_tso_read_only,
            default_object_lock_retention_mode: bucket.default_object_lock_retention_mode,
            default_object_lock_retention_years: bucket.default_object_lock_retention_years,
            default_object_lock_retention_days: bucket.default_object_lock_retention_days,
            default_retention: bucket.default_retention,
            block_size_in_g_b: bucket.block_size_in_g_b,
            auto_commit_period: bucket.auto_commit_period,
            notification_size_in_g_b: bucket.notification_size_in_g_b,
            block_size_in_count: bucket.block_size_in_count,
            notification_size_in_count: bucket.notification_size_in_count,
            is_encryption_enabled: bucket.is_encryption_enabled,
            retention: bucket.retention,
            default_group: bucket.default_group,
            default_group_file_read_permission: bucket.default_group_file_read_permission,
            default_group_file_write_permission: bucket.default_group_file_write_permission,
            default_group_file_execute_permission: bucket.default_group_file_execute_permission,
            default_group_dir_read_permission: bucket.default_group_dir_read_permission,
            default_group_dir_write_permission: bucket.default_group_dir_write_permission,
            default_group_dir_execute_permission: bucket.default_group_dir_execute_permission,
            min_max_governor: bucket::MinMaxGovernor::from(bucket.min_max_governor),
            audit_delete_expiration: bucket.audit_delete_expiration,
            enable_advanced_metadata_search: bucket.enable_advanced_metadata_search,
            advanced_metadata_search_target_name: bucket.advanced_metadata_search_target_name,
            advanced_metadata_search_target_stream: bucket.advanced_metadata_search_target_stream,
            is_empty_bucket_in_progress: bucket.is_empty_bucket_in_progress,
            meta_data: bucket::SearchMetaData::from(bucket.meta_data),
            local_object_metadata_reads: bucket.local_object_metadata_reads,
            apitype: bucket.apitype,
            bucket_owner: bucket.bucket_owner,
            tags: bucket
                .tags
                .into_iter()
                .map(bucket::BucketTag::from)
                .collect(),
        }
    }
}

#[pymethods]
impl Bucket {
    #[new]
    fn new() -> Self {
        Self::default()
    }

    fn __str__(&self) -> String {
        format!("{:?}", self)
    }
}

// Lables for bucket.
#[derive(Clone, Debug, Default)]
#[pyclass(get_all)]
pub(crate) struct BucketTag {
    // The key of a tag.
    #[pyo3(set)]
    key: String,
    // The value of a tag.
    #[pyo3(set)]
    value: String,
}

impl From<bucket::BucketTag> for BucketTag {
    fn from(bucket_tag: bucket::BucketTag) -> Self {
        Self {
            key: bucket_tag.key,
            value: bucket_tag.value,
        }
    }
}

impl From<BucketTag> for bucket::BucketTag {
    fn from(bucket_tag: BucketTag) -> Self {
        Self {
            key: bucket_tag.key,
            value: bucket_tag.value,
        }
    }
}

#[pymethods]
impl BucketTag {
    #[new]
    fn new() -> Self {
        Self::default()
    }

    fn __str__(&self) -> String {
        format!("{:?}", self)
    }
}

//
#[derive(Clone, Debug, Default)]
#[pyclass(get_all)]
pub(crate) struct Link {
    //
    #[pyo3(set)]
    rel: String,
    //
    #[pyo3(set)]
    href: String,
}

impl From<bucket::Link> for Link {
    fn from(link: bucket::Link) -> Self {
        Self {
            rel: link.rel,
            href: link.href,
        }
    }
}

impl From<Link> for bucket::Link {
    fn from(link: Link) -> Self {
        Self {
            rel: link.rel,
            href: link.href,
        }
    }
}

#[pymethods]
impl Link {
    #[new]
    fn new() -> Self {
        Self::default()
    }

    fn __str__(&self) -> String {
        format!("{:?}", self)
    }
}

//
#[derive(Clone, Debug, Default)]
#[pyclass(get_all)]
pub(crate) struct MetaData {
    // The meta key type
    #[pyo3(set)]
    key_data_type: String,
    // The meta key name
    #[pyo3(set)]
    key_value: String,
    // The meta key data type
    #[pyo3(set)]
    metadata_type: String,
}

impl From<bucket::MetaData> for MetaData {
    fn from(meta_data: bucket::MetaData) -> Self {
        Self {
            key_data_type: meta_data.key_data_type,
            key_value: meta_data.key_value,
            metadata_type: meta_data.metadata_type,
        }
    }
}

impl From<MetaData> for bucket::MetaData {
    fn from(meta_data: MetaData) -> Self {
        Self {
            key_data_type: meta_data.key_data_type,
            key_value: meta_data.key_value,
            metadata_type: meta_data.metadata_type,
        }
    }
}

#[pymethods]
impl MetaData {
    #[new]
    fn new() -> Self {
        Self::default()
    }

    fn __str__(&self) -> String {
        format!("{:?}", self)
    }
}

//
#[derive(Clone, Debug, Default)]
#[pyclass(get_all)]
pub(crate) struct MinMaxGovernor {
    //
    #[pyo3(set)]
    enforce_retention: bool,
    //
    #[pyo3(set)]
    minimum_fixed_retention: i64,
    //
    #[pyo3(set)]
    maximum_fixed_retention: i64,
    //
    #[pyo3(set)]
    minimum_variable_retention: i64,
    //
    #[pyo3(set)]
    maximum_variable_retention: i64,
}

impl From<bucket::MinMaxGovernor> for MinMaxGovernor {
    fn from(min_max_governor: bucket::MinMaxGovernor) -> Self {
        Self {
            enforce_retention: min_max_governor.enforce_retention,
            minimum_fixed_retention: min_max_governor.minimum_fixed_retention,
            maximum_fixed_retention: min_max_governor.maximum_fixed_retention,
            minimum_variable_retention: min_max_governor.minimum_variable_retention,
            maximum_variable_retention: min_max_governor.maximum_variable_retention,
        }
    }
}

impl From<MinMaxGovernor> for bucket::MinMaxGovernor {
    fn from(min_max_governor: MinMaxGovernor) -> Self {
        Self {
            enforce_retention: min_max_governor.enforce_retention,
            minimum_fixed_retention: min_max_governor.minimum_fixed_retention,
            maximum_fixed_retention: min_max_governor.maximum_fixed_retention,
            minimum_variable_retention: min_max_governor.minimum_variable_retention,
            maximum_variable_retention: min_max_governor.maximum_variable_retention,
        }
    }
}

#[pymethods]
impl MinMaxGovernor {
    #[new]
    fn new() -> Self {
        Self::default()
    }

    fn __str__(&self) -> String {
        format!("{:?}", self)
    }
}

//
#[derive(Clone, Debug, Default)]
#[pyclass(get_all)]
pub(crate) struct SearchMetaData {
    // Getter for the enabled flag.
    #[pyo3(set)]
    is_enabled: bool,
    //
    #[pyo3(set)]
    meta_data: Vec<MetaData>,
    // Getter for maxKeys.
    #[pyo3(set)]
    max_keys: i32,
    // Getter for the mdTokens flag.
    #[pyo3(set)]
    md_tokens: bool,
}

impl From<bucket::SearchMetaData> for SearchMetaData {
    fn from(search_meta_data: bucket::SearchMetaData) -> Self {
        Self {
            is_enabled: search_meta_data.is_enabled,
            meta_data: search_meta_data
                .meta_data
                .into_iter()
                .map(MetaData::from)
                .collect(),
            max_keys: search_meta_data.max_keys,
            md_tokens: search_meta_data.md_tokens,
        }
    }
}

impl From<SearchMetaData> for bucket::SearchMetaData {
    fn from(search_meta_data: SearchMetaData) -> Self {
        Self {
            is_enabled: search_meta_data.is_enabled,
            meta_data: search_meta_data
                .meta_data
                .into_iter()
                .map(bucket::MetaData::from)
                .collect(),
            max_keys: search_meta_data.max_keys,
            md_tokens: search_meta_data.md_tokens,
        }
    }
}

#[pymethods]
impl SearchMetaData {
    #[new]
    fn new() -> Self {
        Self::default()
    }

    fn __str__(&self) -> String {
        format!("{:?}", self)
    }
}
