//
// Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//

//! Define the bucket details.
//!
use crate::client::ObjectstoreClient;
use crate::response::get_content_text;
use anyhow::{bail, Context as _, Result};
use derive_builder::Builder;
use reqwest::header::{ACCEPT, AUTHORIZATION, CONTENT_TYPE};
use serde::{Deserialize, Serialize};
use serde_aux::field_attributes::{deserialize_bool_from_anything, deserialize_default_from_null};

#[derive(Clone, Default, Debug, Deserialize, Serialize)]
#[serde(rename_all(serialize = "snake_case", deserialize = "camelCase"))]
pub struct Link {
    pub rel: String,
    pub href: String,
}

#[derive(Clone, Default, Debug, Deserialize, Serialize)]
#[serde(rename_all(serialize = "snake_case", deserialize = "camelCase"))]
pub struct MinMaxGovernor {
    pub enforce_retention: bool,
    #[serde(deserialize_with = "deserialize_default_from_null")]
    pub minimum_fixed_retention: i64,
    // TODO: need to understand the default value
    #[serde(deserialize_with = "deserialize_default_from_null")]
    pub maximum_fixed_retention: i64,
    #[serde(deserialize_with = "deserialize_default_from_null")]
    pub minimum_variable_retention: i64,
    #[serde(deserialize_with = "deserialize_default_from_null")]
    pub maximum_variable_retention: i64,
}

#[derive(Clone, Default, Debug, Deserialize, Serialize)]
#[serde(rename_all(serialize = "snake_case", deserialize = "camelCase"))]
pub struct MetaData {
    /// The meta key type
    pub key_data_type: String,
    /// The meta key name
    pub key_value: String,
    /// The meta key data type
    pub metadata_type: String,
}

#[derive(Clone, Default, Debug, Deserialize, Serialize)]
#[serde(rename_all(serialize = "snake_case", deserialize = "camelCase"))]
pub struct SearchMetaData {
    /// Getter for the enabled flag.
    pub is_enabled: bool,
    #[serde(deserialize_with = "deserialize_default_from_null")]
    pub meta_data: Vec<MetaData>,
    /// Getter for maxKeys.
    pub max_keys: i32,
    /// Getter for the mdTokens flag.
    pub md_tokens: bool,
}

/// Lables for bucket.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all(serialize = "PascalCase", deserialize = "camelCase"))]
pub struct BucketTag {
    /// The key of a tag.
    pub key: String,
    /// The value of a tag.
    pub value: String,
}

/// Buckets are object containers that are used to control access to objects. ObjectScale supports bucket-to-bucket replication of the objects within a bucket.
#[derive(Builder, Clone, Debug, Default, Deserialize, Serialize)]
#[builder(setter(skip))]
#[serde(
    rename_all(serialize = "snake_case", deserialize = "camelCase"),
    rename(serialize = "object_bucket_create")
)]
pub struct Bucket {
    /// Name assigned to this resource in ECS. The resource name is set by a user and can be changed at any time. It is not a unique identifier.
    #[builder(setter(into))]
    pub name: String,
    /// Identifier that is generated by ECS when the resource is created. The resource Id is guaranteed to be unique and immutable across all virtual data centers for all time.
    pub id: String,
    /// Hyperlink to the details for this resource
    pub link: Link,
    #[builder(setter(into))]
    /// Namespace
    pub namespace: String,
    pub replication: String,
    /// "Locked" status of a bucket
    pub locked: bool,
    /// Bucket "file system access enabled" status
    pub fs_acess_enabled: bool,
    /// Bucket soft quota
    pub soft_quota: String,
    /// Bucket creation time
    pub created: String,
    /// Bucket isStaleAllowed flag
    pub is_stale_allowed: bool,
    /// If true Object Lock and ADO can be enabled together. See the Admin Guide for more information.
    pub object_lock_with_ado_allowed: bool,
    /// Bucket isStaleAllowed flag
    pub is_tso_read_only: bool,
    /// Default object lock retention mode
    #[serde(deserialize_with = "deserialize_default_from_null")]
    pub default_object_lock_retention_mode: String,
    /// Default object lock retention years
    #[serde(deserialize_with = "deserialize_default_from_null")]
    pub default_object_lock_retention_years: i32,
    /// Default object lock retention days
    #[serde(deserialize_with = "deserialize_default_from_null")]
    pub default_object_lock_retention_days: i32,
    /// Default bucket retention
    pub default_retention: i64,
    /// Block size in GB
    pub block_size_in_g_b: i64,
    /// auto-commit interval
    pub auto_commit_period: i64,
    /// Notification size in GB
    pub notification_size_in_g_b: i64,
    pub block_size_in_count: i64,
    pub notification_size_in_count: i64,
    /// Bucket isEncryptionEnabled flag
    #[builder(setter(skip = false), default = "false")]
    #[serde(deserialize_with = "deserialize_bool_from_anything")]
    pub is_encryption_enabled: bool,
    /// Default retention value for the bucket.
    pub retention: i64,
    /// Bucket's default group
    #[serde(deserialize_with = "deserialize_default_from_null")]
    pub default_group: String,
    /// Flag indicating the Read permission for default group
    pub default_group_file_read_permission: bool,
    /// Flag indicating the file write permission for default group
    pub default_group_file_write_permission: bool,
    /// Flag indicating the file execute permission for default group
    pub default_group_file_execute_permission: bool,
    /// Flag indicating the directory read permission for default group. This is only applicable to folders created within the Filesystem-Enabled bucket. It is not applicable to files/objects
    pub default_group_dir_read_permission: bool,
    /// Flag indicating the directory write permission for default group. This is only applicable to folders created within the Filesystem-Enabled bucket. It is not applicable to files/objects
    pub default_group_dir_write_permission: bool,
    /// Flag indicating the directory execute permission for default group. This is only applicable to folders created within the Filesystem-Enabled bucket. It is not applicable to files/objects
    pub default_group_dir_execute_permission: bool,
    pub min_max_governor: MinMaxGovernor,
    /// Bucket audit delete expiration in seconds
    #[builder(setter(skip = false), default = "-2")]
    #[serde(rename(serialize = "audited_delete_expiration"))]
    pub audit_delete_expiration: i64,
    pub enable_advanced_metadata_search: bool,
    #[serde(deserialize_with = "deserialize_default_from_null")]
    pub advanced_metadata_search_target_name: String,
    #[serde(deserialize_with = "deserialize_default_from_null")]
    pub advanced_metadata_search_target_stream: String,
    /// Optional. If true the bucket is in the process of being deleted. The bucket will be read only and no changes will be allowed on the bucket until the operation completes.
    pub is_empty_bucket_in_progress: bool,
    pub meta_data: SearchMetaData,
    /// Local object metadata reads bucket flag.
    pub local_object_metadata_reads: bool,
    /// API type
    pub apitype: String,
    /// Bucket owner
    pub bucket_owner: String,
    /// Keywords and labels that can be added by a user to a resource to make it easy to find when doing a search.
    #[builder(setter(skip = false), default)]
    #[serde(rename = "TagSet", deserialize_with = "deserialize_default_from_null")]
    pub tags: Vec<BucketTag>,
}

// dose not deserialize all the fields for create bucket response
// as the schema does not align with get bucket response
// would issue get bucket request in addition after creation and send the response accordingly
#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct CreateBucketResponse {
    pub name: String,
    pub id: String,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
struct ListBucketsResponse {
    // Does not align with API description
    pub object_bucket_list: Vec<Bucket>,
    pub filter: String,
    pub next_marker: Option<String>,
    pub max_buckets: Option<u32>,
    pub next_page_link: Option<String>,
}

impl Bucket {
    pub(crate) fn create(client: &mut ObjectstoreClient, bucket: Bucket) -> Result<String> {
        let request_url = format!("{}object/bucket.json", client.endpoint);
        let body = quick_xml::se::to_string(&bucket)?;
        let resp = client
            .management_client
            .http_client
            .post(request_url)
            .header(ACCEPT, "application/json")
            .header(
                AUTHORIZATION,
                client.management_client.access_token.as_ref().unwrap(),
            )
            .header(CONTENT_TYPE, "application/xml")
            .body(body)
            .send()?;
        let text = get_content_text(resp)?;
        let resp: CreateBucketResponse = serde_json::from_str(&text).with_context(|| {
            format!(
                "Unable to deserialise CreateBucketResponse. Body was: \"{}\"",
                text
            )
        })?;
        Ok(resp.name)
    }

    pub(crate) fn tag(
        client: &mut ObjectstoreClient,
        bucket_name: &str,
        namespace: &str,
        tags: Vec<BucketTag>,
    ) -> Result<()> {
        // TODO:
        // quick_xml dose not serialize object vector with object name
        // serialize to string directly once https://github.com/tafia/quick-xml/pull/784 is resolved
        let tags = tags
            .iter()
            .map(|tag| quick_xml::se::to_string_with_root("Tag", tag).unwrap())
            .collect::<Vec<String>>()
            .join("");
        let body = format!(
            r#"<add_bucket_tags><TagSet>{}</TagSet><namespace>{}</namespace></add_bucket_tags>"#,
            tags, namespace
        );
        let request_url = format!("{}object/bucket/{}/tags", client.endpoint, bucket_name);
        let resp = client
            .management_client
            .http_client
            .post(request_url)
            .header(ACCEPT, "application/json")
            .header(
                AUTHORIZATION,
                client.management_client.access_token.as_ref().unwrap(),
            )
            .header(CONTENT_TYPE, "application/xml")
            .body(body)
            .send()?;
        if !resp.status().is_success() {
            bail!("Request failed: {}", resp.text()?);
        }
        Ok(())
    }

    pub(crate) fn get(
        client: &mut ObjectstoreClient,
        name: &str,
        namespace: &str,
    ) -> Result<Bucket> {
        let request_url = format!(
            "{}object/bucket/{}/info.json?namespace={}",
            client.endpoint, name, namespace,
        );
        let resp = client
            .management_client
            .http_client
            .get(request_url)
            .header(ACCEPT, "application/json")
            .header(
                AUTHORIZATION,
                client.management_client.access_token.as_ref().unwrap(),
            )
            .send()?;
        let text = get_content_text(resp)?;
        let resp: Bucket = serde_json::from_str(&text)
            .with_context(|| format!("Unable to deserialise GetBucket. Body was: \"{}\"", text))?;
        Ok(resp)
    }

    pub(crate) fn update(client: &mut ObjectstoreClient, bucket: Bucket) -> Result<()> {
        // Set Bucket Audit Delete Expiration
        let request_url = format!(
            "{}object/bucket/{}/auditDeleteExpiration?expiration={}&namespace={}",
            client.endpoint, bucket.name, bucket.audit_delete_expiration, bucket.namespace,
        );
        let body = quick_xml::se::to_string(&bucket)?;
        let resp = client
            .management_client
            .http_client
            .put(request_url)
            .header(ACCEPT, "application/json")
            .header(
                AUTHORIZATION,
                client.management_client.access_token.as_ref().unwrap(),
            )
            .body(body)
            .send()?;
        if !resp.status().is_success() {
            bail!("Request failed: {}", resp.text()?);
        }
        Ok(())
    }

    pub(crate) fn delete(
        client: &mut ObjectstoreClient,
        name: &str,
        namespace: &str,
        empty_bucket: bool,
    ) -> Result<()> {
        let request_url = format!(
            "{}object/bucket/{}/deactivate.json?namespace={}&emptyBucket={}",
            client.endpoint, name, namespace, empty_bucket,
        );
        let resp = client
            .management_client
            .http_client
            .post(request_url)
            .header(ACCEPT, "application/json")
            .header(
                AUTHORIZATION,
                client.management_client.access_token.as_ref().unwrap(),
            )
            .send()?;
        if !resp.status().is_success() {
            bail!("Request failed: {}", resp.text()?);
        } else if resp.status().as_u16() == 202 {
            // TODO: whether to check response
            // it may last for a while
            bail!("Deletion ongoing");
        } else {
            Ok(())
        }
    }

    pub(crate) fn list(
        client: &mut ObjectstoreClient,
        namespace: &str,
        name_prefix: &str,
    ) -> Result<Vec<Bucket>> {
        let prefix = if name_prefix.is_empty() {
            "".to_string()
        } else {
            format!("&name={}", name_prefix)
        };
        let request_url = format!(
            "{}object/bucket.json?namespace={}{}",
            client.endpoint, namespace, prefix,
        );
        let resp = client
            .management_client
            .http_client
            .get(request_url)
            .header(ACCEPT, "application/json")
            .header(
                AUTHORIZATION,
                client.management_client.access_token.as_ref().unwrap(),
            )
            .send()?;
        let text = get_content_text(resp)?;
        let mut resp: ListBucketsResponse = serde_json::from_str(&text).with_context(|| {
            format!(
                "Unable to deserialise ListBuckestResponse. Body was: \"{}\"",
                text
            )
        })?;
        let mut buckets: Vec<Bucket> = vec![];
        buckets.extend(resp.object_bucket_list);
        while let Some(marker) = resp.next_marker {
            let request_url = format!(
                "{}object/bucket.json?namespace={}{}&marker={}",
                client.endpoint, namespace, prefix, marker,
            );
            let response = client
                .management_client
                .http_client
                .get(request_url)
                .header(ACCEPT, "application/json")
                .header(
                    AUTHORIZATION,
                    client.management_client.access_token.as_ref().unwrap(),
                )
                .send()?;
            let text = get_content_text(response)?;
            resp = serde_json::from_str(&text).with_context(|| {
                format!(
                    "Unable to deserialise ListBucketsResponse. Body was: \"{}\"",
                    text
                )
            })?;
            buckets.extend(resp.object_bucket_list);
        }
        Ok(buckets)
    }
}
